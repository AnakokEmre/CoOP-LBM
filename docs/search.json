[{"path":"/articles/Available_options.html","id":"options-for-the-exploration-procedure","dir":"Articles","previous_headings":"","what":"Options for the exploration procedure","title":"Available options","text":"following options concerns exploration procedure fit_unsupervised_LBM fit_unsupervised_CoOP_LBM functions, part number groups changing order explore best fit. arguments must list containing option.","code":""},{"path":"/articles/Available_options.html","id":"plots","dir":"Articles","previous_headings":"Options for the exploration procedure","what":"Plots","title":"Available options","text":"deactivate plots use :","code":"fit_unsupervised_CoOP_LBM(M,exploOptions = list(plot=F))"},{"path":"/articles/Available_options.html","id":"verbosity","dir":"Articles","previous_headings":"Options for the exploration procedure","what":"Verbosity","title":"Available options","text":"deactivate prints, use:","code":"fit_unsupervised_CoOP_LBM(M,exploOptions = list(verbosity=F))"},{"path":"/articles/Available_options.html","id":"initialization-type","dir":"Articles","previous_headings":"Options for the exploration procedure","what":"Initialization type","title":"Available options","text":"several ways initialize clustering exploration. default initialization hierarchical clustering. Spectral K-means clustering also available. want change initialization, use :","code":"fit_unsupervised_CoOP_LBM(M,exploOptions = list(initMethod=\"spectral_clust\")) fit_unsupervised_CoOP_LBM(M,exploOptions = list(initMethod=\"kmeans_clust\"))"},{"path":"/articles/Available_options.html","id":"maximum-exploration","dir":"Articles","previous_headings":"Options for the exploration procedure","what":"Maximum Exploration","title":"Available options","text":"algorithm keeps increasing number groups ICL increases. ICL decrease, algorithm keeps increasing number groups reaches number groups greater 1.5 times best matches. change value, use :","code":"fit_unsupervised_CoOP_LBM(M,exploOptions = list(maxEplo=2))"},{"path":"/articles/Available_options.html","id":"maximum-number-of-groups","dir":"Articles","previous_headings":"Options for the exploration procedure","what":"Maximum Number of Groups","title":"Available options","text":"algorithm keeps increasing number groups ICL increases, stop number groups greater 10. change threshold, use : threshold canâ€™t lower 4.","code":"fit_unsupervised_CoOP_LBM(M,exploOptions = list(maxGroups=15))"},{"path":"/articles/Available_options.html","id":"reinitialize-the-exploration","dir":"Articles","previous_headings":"Options for the exploration procedure","what":"Reinitialize the exploration","title":"Available options","text":"deeper exploration parameters, exploration can done backward forward maximum groups found. exploration leads precise result time consuming. Use :","code":"fit_unsupervised_CoOP_LBM(M,exploOptions = list(reinitialize  = TRUE))"},{"path":"/articles/Available_options.html","id":"options-for-the-estimation-procedure","dir":"Articles","previous_headings":"","what":"Options for the estimation procedure","title":"Available options","text":"following options concerns estimation procedure, done number fixed groups. options different LBM CoOP-LBM, available unsupervised function supervised counterparts.","code":""},{"path":[]},{"path":"/articles/Available_options.html","id":"maximum-iteration","dir":"Articles","previous_headings":"Options for the estimation procedure > LBM","what":"Maximum Iteration","title":"Available options","text":"change maximum number iteration VEM algorithm, default value 50, use :","code":"fit_unsupervised_LBM(M,estimOptions = list(maxIter  = 100))"},{"path":"/articles/Available_options.html","id":"variational-fixed-point-algorithm","dir":"Articles","previous_headings":"Options for the estimation procedure > LBM","what":"Variational fixed point algorithm","title":"Available options","text":"variational parameters calculated fixed point algorithm, default number iteration 3. change value, use :","code":"fit_unsupervised_LBM(M,estimOptions = list(fixPointIter  = 3))"},{"path":"/articles/Available_options.html","id":"threshold-of-convergence","dir":"Articles","previous_headings":"Options for the estimation procedure > LBM","what":"Threshold of convergence","title":"Available options","text":"estimation parameters stops relative distance estimation next threshold equals 1e-3. change threshold, use :","code":"fit_unsupervised_LBM(M,estimOptions = list(threshold     = 1e-4))"},{"path":[]},{"path":"/articles/Available_options.html","id":"maximum-iteration-during-burn-in","dir":"Articles","previous_headings":"Options for the estimation procedure > CoOP-LBM","what":"Maximum Iteration during burn in","title":"Available options","text":"change maximum number iteration SEM algorithm burn period, default value 50, use :","code":"fit_unsupervised_CoOP_LBM(M,estimOptions = list(maxHeat  = 100))"},{"path":"/articles/Available_options.html","id":"maximum-iteration-after-burn-in","dir":"Articles","previous_headings":"Options for the estimation procedure > CoOP-LBM","what":"Maximum Iteration after burn in","title":"Available options","text":"change maximum number iteration SEM algorithm burn period, default value 10000, use :","code":"fit_unsupervised_CoOP_LBM(M,estimOptions = list(maxIter  = 100))"},{"path":"/articles/Available_options.html","id":"fixed-point-algorithm","dir":"Articles","previous_headings":"Options for the estimation procedure > CoOP-LBM","what":"Fixed point algorithm","title":"Available options","text":"sampling effort parameters calculated fixed point algorithm, default number iteration 3. change value, use :","code":"fit_unsupervised_CoOP_LBM(M,estimOptions = list(fixPointIter  = 3))"},{"path":"/articles/example.html","id":"simulation-for-k-iteration","dir":"Articles","previous_headings":"","what":"Simulation for K iteration","title":"Example","text":"","code":"n1 = 100 n2 = 100 Q1 = 3 Q2 = 3 P =matrix(c(0.95,0.75,0.5,                  0.75,0.5,0.5,                  0.5,0.5,0.05),Q1,Q2)   alpha1 = c(1/3,1/3,1/3) alpha2 = c(1/3,1/3,1/3) result = data.frame(Q1_LBM=numeric(),                    Q2_LBM=numeric(),                          Q1_CoOP= numeric(),                    Q2_CoOP= numeric(),                    ARI_row_LBM=numeric(),                    ARI_col_LBM=numeric(),                    ARI_row_CoOP = numeric(),                    ARI_col_CoOP = numeric(),                    Connectivity_M = numeric(),                    Connectivity_V = numeric(),                    Connectivity_LBM = numeric(),                    Connectivity_CoOP = numeric(),                    Connectivity_Chao = numeric(),                    RMSE_chao_row_coverage= numeric(),                    RMSE_chao_col_coverage= numeric(),                    RMSE_CoOP_row_coverage= numeric(),                    RMSE_CoOP_col_coverage= numeric(),                    NODF_M = numeric(),                    NODF_V= numeric(),                    NODF_LBM = numeric(),                    NODF_CoOP= numeric(),                    NODF_Random= numeric(),                    MOD_M = numeric(),                    MOD_V= numeric(),                    MOD_LBM = numeric(),                    MOD_CoOP= numeric(),                    MOD_Random= numeric(),                    rob_M = numeric(),                    rob_LBM = numeric(),                    rob_LBM_corrected = numeric(),                    rob_CoOP = numeric(),                                     G = numeric(),                    G_CoOP = numeric(),                    RMSE_lambda=numeric(),                    RMSE_mu = numeric(),                    RMSE_lambda_mu_G = numeric(),                    AUC_LBM = numeric(),                    AUC_CoOP = numeric()                    ) list_G = c(300,400) ### CHANGE THE LIST TO CHANGE THE EXPLORATION OF G K = 10 # NUMBER OF ITERATION FOR EACH G  print_result = FALSE # CHANGE TO TRUE IF YOU WANT TO PRINT RESULT AT EACH ITERATION  for (G in list_G){ for (k in 1:K){   print(k) simulation1=simulate_lbm(P,alpha1,alpha2,n1,n2) M = simulation1$A Z1 =simulation1$Z Z2 =simulation1$W lambda_i =rbeta(n1,0.3,1.5) mu_j = rbeta(n2,0.3,1.5) lambda_i = lambda_i/max(lambda_i) mu_j = mu_j/max(mu_j) N0=lambda_i%*%t(mu_j)*G N=matrix(rpois(n1*n2,N0),nrow=n1) R = M*N  obsrow = rowSums(R)>0 obscol = colSums(R)>0 R_obs = R[obsrow,obscol] M_obs = M[obsrow,obscol] Z1_obs = Z1[obsrow] Z2_obs = Z2[obscol] V = 1*(R_obs>0) try1=fit_unsupervised_LBM(V,exploOptions = list(plot=FALSE,verbosity=F)) try2=fit_unsupervised_CoOP_LBM(R_obs,exploOptions = list(plot=F,verbosity=F))  model1 = try1[[best_ICL(try1)]] model2 = try2[[best_ICL(try2)]]    #________________ARI SCORE________________    ARIL1=ARI(model1$cluster1,Z1_obs) ARIC1=ARI(model1$cluster2,Z2_obs)  ARIL2=ARI(model2$cluster1,Z1_obs) ARIC2=ARI(model2$cluster2,Z2_obs)   #________________COMPLETION OF MATRIX________________  V2 =V V2[V2==0][sample(1:sum(V2==0),size = sum(M_obs)-sum(V),prob=model1$pi[model1$cluster1,model1$cluster2][V==0])]=1 V3 = V V3 =1*( runif(prod(dim(V)))< model2$connectivity_prob) V4 = V V4[V4==0][sample(1:sum(V4==0),size = sum(M_obs)-sum(V))]=1  #________________CONNECTIVITY________________  F1 = sum(R_obs==1) F2 = sum(R_obs==2)  Connectivity_M = round(mean(M),3) Connectivity_V = round(mean(V),3) Connectivity_LBM = round(model1$alpha1%*%model1$pi%*%model1$alpha2,3) Connectivity_CoOP = round(model2$alpha1%*%model2$pi%*%model2$alpha2,3) Chao =round(mean(V)/(1 - F1/sum(R_obs) * (sum(R_obs)-1)*F1/((sum(R_obs)-1)*F1+2*(F2+1))),3)  #________________COVERAGE________________  fL1 = rowSums(R_obs==1) fL2 = rowSums(R_obs==2)  fC1 = colSums(R_obs==1) fC2 = colSums(R_obs==2)   ChaoL = 1 - fL1/rowSums(R_obs) * (rowSums(R_obs)-1)*fL1/((rowSums(R_obs)-1)*fL1+2*(fL2+1)) ChaoC = 1 - fC1/colSums(R_obs) * (colSums(R_obs)-1)*fC1/((colSums(R_obs)-1)*fC1+2*(fC2+1))  RMSE_chao_L = sqrt(mean((ChaoL-rowSums(R_obs>0)/rowSums(M[rowSums(R)>0,]))**2)) RMSE_chao_C = sqrt(mean((ChaoC-colSums(R_obs>0)/colSums(M[,colSums(R)>0]))**2))  RMSE_CoOP_L = sqrt(mean((model2$row_coverage-rowSums(R_obs>0)/rowSums(M[rowSums(R)>0,]))**2)) RMSE_CoOP_C = sqrt(mean((model2$col_coverage-colSums(R_obs>0)/colSums(M[,colSums(R)>0]))**2))  #________________NESTEDNESS________________  NODF_M = round(NODF(M)$matrix,3) NODF_V = round(NODF(V)$matrix,3) NODF_LBM = round(NODF(V2)$matrix,3) NODF_CoOP = round(NODF(V3)$matrix,3) NODF_Random = round(NODF(V4)$matrix,3)   #________________MODULARITY________________  MOD_M = round(NOS(M)$mod,3) MOD_V = round(NOS(V)$mod,3) MOD_LBM = round(NOS(V2)$mod,3) MOD_CoOP = round(NOS(V3)$mod,3) MOD_Random = round(NOS(V4)$mod,3)    #________________ROBUSTNESS________________  rob0= round(robustness_lbm(con = P,pi = c(1/3,1/3,1/3),rho = c(1/3,1/3,1/3),nr = 100,nc = 100)$auc,3) rob1 = round(robustness_lbm(con =model1$pi,pi = model1$alpha1,rho =model1$alpha2,nr =dim(V)[1],nc = dim(V)[2])$auc,3) P_LBM = model1$pi*mean(M)/mean(V) P_LBM[P_LBM>1]=1 rob1.2 = round(robustness_lbm(con =P_LBM,pi = model1$alpha1,rho =model1$alpha2,nr =dim(V)[1],nc = dim(V)[2])$auc,3) rob2 = round(robustness_lbm(con =model2$pi,pi = model2$alpha1,rho =model2$alpha2,nr =dim(V)[1],nc = dim(V)[2])$auc,3)    #________________RMSE________________   RMSE_lambda = sqrt(mean((lambda_i[obsrow]-model2$lambda)**2)) RMSE_mu = sqrt(mean((mu_j[obscol]-model2$mu)**2)) RMSE_lambda_mu_G = sqrt(mean((N0[obsrow,obscol]-model2$lambda_mu_G)**2))  #________________AUC________________  proba_connect1 = model1$pi[model1$cluster1,model1$cluster2] proba_connect2 = model2$connectivity_prob  AUC_LBM  = auc(roc(M_obs[V==0],proba_connect1[V==0],                    direction=\"<\",levels=levels(as.factor(c(0,1))))) AUC_CoOP = auc(roc(M_obs[V==0],proba_connect2[V==0],                    direction=\"<\",levels=levels(as.factor(c(0,1)))))  #________________PRINT________________ if (print_result){  print(paste0(\"Q1 | LBM = \",dim(model1$pi)[1],\" | CoOP-LBM = \",dim(model2$pi)[1])) print(paste0(\"Q2 | LBM = \",dim(model1$pi)[2],\" | CoOP-LBM = \",dim(model2$pi)[2])) print(paste0(\"row ARI | LBM = \",round(ARIL1,3),\" | CoOP-LBM = \",round(ARIL2,3))) print(paste0(\"col ARI | LBM = \",round(ARIC1,3),\" | CoOP-LBM = \",round(ARIC2,3)))  print(paste0(\"Connectivity | Complete matrix = \" ,Connectivity_M ,\" | Observed matrix = \", Connectivity_V , \" | LBM = \",Connectivity_LBM,\" | CoOP-LBM = \",Connectivity_CoOP,\" | Chao = \",Chao ) ) print(paste0(\"RMSE of row coverage | Chao = \" ,round(RMSE_chao_L,3) ,\" | CoOP-LBM = \", round(RMSE_CoOP_L,3) )) print(paste0(\"RMSE of column coverage | Chao = \" ,round(RMSE_chao_C,3) ,\" | CoOP-LBM = \", round(RMSE_CoOP_C,3) ))  print(paste0(\"NODF | Complete matrix = \" ,NODF_M,\" | Observed matrix = \", NODF_V , \" | LBM = \",NODF_LBM,\" | CoOP-LBM = \",NODF_CoOP,\" | Random = \", NODF_Random   ) ) print(paste0(\"Modularity | Complete matrix = \" ,MOD_M ,\" | Observed matrix = \", MOD_V , \" | LBM = \",MOD_LBM,\" | CoOP-LBM = \",MOD_CoOP,\" | Random = \",MOD_Random ) ) print(paste0(\"Robustness | Complete matrix = \" ,rob0 ,\" | LBM = \", rob1 , \" | Corrected LBM = \",rob1.2,\" | CoOP-LBM = \",rob2))  print(paste0(\"Estimated G : \",round(model2$G,3))) print(paste0(\"RMSE | Lambda = \",round(RMSE_lambda,3),\" | Mu = \",round(RMSE_mu,3))) print(paste0(\"RMSE | Lambda x Mu x G  = \",round(RMSE_lambda_mu_G,3))) print(paste0(\"AUC | LBM  = \",round(AUC_LBM,3),\" | CoOP-LBM = \",round(AUC_CoOP,3) ))   print(\"##########\") } result[nrow(result)+1,] = c(dim(model1$pi)[1],dim(model1$pi)[2],dim(model2$pi)[1],dim(model2$pi)[2],                             ARIL1,ARIC1,ARIL2,ARIC2,                             Connectivity_M,Connectivity_V,Connectivity_LBM,Connectivity_CoOP,Chao,RMSE_chao_L,RMSE_chao_C,RMSE_CoOP_L,RMSE_CoOP_C,NODF_M,NODF_V,NODF_LBM,NODF_CoOP,NODF_Random,MOD_M,MOD_V,MOD_LBM,MOD_CoOP,MOD_Random,rob0,rob1,rob1.2,rob2,G,model2$G,RMSE_lambda,RMSE_mu,RMSE_lambda_mu_G,AUC_LBM,AUC_CoOP)         }} df1 = result[c(\"G\",\"ARI_row_LBM\",\"ARI_row_CoOP\")] df1_long <- melt(df1, id.vars=c(\"G\")) p1 <- ggplot(df1_long, aes(x=factor(G),y=value,fill=variable))+   geom_boxplot() +  theme(legend.position = \"bottom\",axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(\"ARI for row clustering\")+ labs(y=\"ARI\",x=\"G\")+scale_fill_discrete(labels = c(\"LBM\",\"CoOP-LBM\"))+ guides(fill=guide_legend(title=\"\"))  df2 = result[c(\"G\",\"ARI_col_LBM\",\"ARI_col_CoOP\")] df2_long <- melt(df2, id.vars=c(\"G\")) p2 <- ggplot(df2_long, aes(x=factor(G),y=value,fill=variable))+   geom_boxplot()  +  theme(legend.position = \"bottom\",axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(\"ARI for column clustering\")+ labs(y=\"\",x=\"G\")+scale_fill_discrete(labels = c(\"LBM\",\"CoOP-LBM\")) + guides(fill=guide_legend(title=\"\"))   grid.arrange(p1,p2,ncol=2) tbl1 <- with(result, table(Q1_LBM, G)) p3=ggplot(as.data.frame(tbl1), aes(factor(G), Freq, fill = Q1_LBM)) +     theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+labs(x=\"G\")+   geom_col(position = 'stack') tbl2 <- with(result, table(Q2_LBM, G)) p4=ggplot(as.data.frame(tbl2), aes(factor(G), Freq, fill = Q2_LBM)) +     theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+labs(x=\"G\")+   geom_col(position = 'stack') tbl3 <- with(result, table(Q1_CoOP, G)) p5=ggplot(as.data.frame(tbl3), aes(factor(G), Freq, fill = Q1_CoOP)) +     theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+labs(x=\"G\")+   geom_col(position = 'stack') tbl4 <- with(result, table(Q2_CoOP, G)) p6=ggplot(as.data.frame(tbl4), aes(factor(G), Freq, fill = Q2_CoOP)) +     theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+labs(x=\"G\")+   geom_col(position = 'stack')  grid.arrange(p3,p4,p5,p6,ncol=2, nrow = 2) connectivity_q05 = quantile(result$Connectivity_M,0.05) mean_connectivity = alpha1%*%P%*%alpha2  connectivity_q95 = quantile(result$Connectivity_M,0.95)  d_connectivity = data.frame(m=c(connectivity_q05,mean_connectivity,connectivity_q95))   df3 = result[c(\"G\",\"Connectivity_V\",\"Connectivity_Chao\",\"Connectivity_CoOP\")] df3_long <- melt(df3, id.vars=c(\"G\")) p7 <- ggplot(df3_long, aes(x=factor(G),y=value,fill=variable))+   geom_hline(data=d_connectivity,aes(yintercept = m,linetype=c(\"b\",\"a\",\"b\")))+   geom_boxplot()  +  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(\"Connectivity\")+labs(x=\"G\")+guides(fill=guide_legend(title=\"\"))+   scale_fill_discrete(labels = c(\"Observed matrix\",\"Chao\",\"CoOP-LBM\"))+    labs(linetype=\"\")+  scale_linetype_discrete( labels=c(\"Theoretical mean\",\"90% fluctuation interval\")) p7 df4 = result[c(\"G\",\"RMSE_chao_row_coverage\",\"RMSE_CoOP_row_coverage\")]  df4_long <- melt(df4, id.vars=c(\"G\")) p8 <- ggplot(df4_long, aes(x=factor(G),y=value,fill=variable))+   geom_boxplot()  +  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(\"RMSE of row coverage\") + scale_fill_discrete(labels = c(\"Chao\",\"CoOP-LBM\"))+labs(y=\"RMSE\",x=\"G\")+ guides(fill=guide_legend(title=\"\"))   df5 = result[c(\"G\",\"RMSE_chao_col_coverage\",\"RMSE_CoOP_col_coverage\")]  df5_long <- melt(df5, id.vars=c(\"G\")) p9 <- ggplot(df5_long, aes(x=factor(G),y=value,fill=variable))+   geom_boxplot()  +  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(\"RMSE of column coverage\") + scale_fill_discrete(labels = c(\"Chao\",\"CoOP-LBM\"))+labs(y=\"RMSE\",x=\"G\")+ guides(fill=guide_legend(title=\"\"))   grid.arrange(p8,p9, nrow = 2) df6 = result[c(\"G\",\"NODF_V\",\"NODF_LBM\",\"NODF_CoOP\",\"NODF_Random\")]  nodf_q05 = quantile(result$NODF_M,0.05) nodf_mean = mean(result$NODF_M) nodf_q95 = quantile(result$NODF_M,0.95)  d6 = data.frame(m=c(nodf_q05,nodf_mean ,nodf_q95 ))   df6_long <- melt(df6, id.vars=c(\"G\")) p10 <- ggplot(df6_long, aes(x=factor(G),y=value,fill=variable))+   geom_hline(data=d6,aes(yintercept = m,linetype=c(\"b\",\"a\",\"b\")))+   geom_boxplot()  +  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +   ggtitle(\"Nestedness\")+   scale_fill_discrete(labels = c(\"Observed matrix\",\"Oracle LBM\",\"CoOP-LBM\",\"Randomly completed\"))+  guides(fill=guide_legend(title=\"\")) + labs(color=\"\",shape=\"\",y=\"Nestedness\",x=\"G\")+    labs(linetype=\"\")+  scale_linetype_discrete( labels=c(\"empirical mean\",\"90% fluctuation interval\"))  p10 df7 = result[c(\"G\",\"MOD_V\",\"MOD_LBM\",\"MOD_CoOP\",\"MOD_Random\")]  MOD_q05 = quantile(result$MOD_M,0.05) MOD_mean = mean(result$MOD_M) MOD_q95 = quantile(result$MOD_M,0.95)  d7 = data.frame(m=c(MOD_q05,MOD_mean ,MOD_q95 ))   df7_long <- melt(df7, id.vars=c(\"G\")) p11 <- ggplot(df7_long, aes(x=factor(G),y=value,fill=variable))+   geom_hline(data=d7,aes(yintercept = m,linetype=c(\"b\",\"a\",\"b\")))+   geom_boxplot()  +    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +   ggtitle(\"Modularity\")+   scale_fill_discrete(labels = c(\"Observed matrix\",\"Oracle LBM\",\"CoOP-LBM\",\"Randomly completed\"))+  guides(fill=guide_legend(title=\"\")) + labs(color=\"\",shape=\"\",y=\"Modularity\",x=\"G\")+    labs(linetype=\"\")+  scale_linetype_discrete( labels=c(\"empirical mean\",\"90% fluctuation interval\"))  p11 df8 = result[c(\"G\",\"rob_LBM\",\"rob_LBM_corrected\",\"rob_CoOP\")] df8_long <- melt(df8, id.vars=c(\"G\"))  rob_mean = mean(result$rob_M)  p12 <-  ggplot(df8_long, aes(x=factor(G),y=value,fill=variable))+   geom_hline(aes(yintercept=rob_mean,linetype=\"Theoretical mean\"))+   geom_boxplot()  +  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+   ggtitle(\"Robustness\")+   scale_fill_discrete(labels = c(\"LBM\",\"Oracle LBM\",\"CoOP-LBM\"))+    labs(color=\"\",shape=\"\",y=\"Robustness\",x=\"G\")+   guides(fill=guide_legend(title=\"\"),linetype=guide_legend(title=\"\") ) p12 df9 = result[c(\"G\",\"AUC_LBM\",\"AUC_CoOP\")]  df9_long <- melt(df9, id.vars=c(\"G\")) p13 <- ggplot(df9_long, aes(x=factor(G),y=value,fill=variable))+   geom_boxplot()  +  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(\"AUC for missing data\")+scale_fill_discrete(labels = c(\"LBM\",\"CoOP-LBM\")) + guides(fill=guide_legend(title=\"\"))+labs(y=\"AUC\",x=\"G\") p13 df10 = result[c(\"G\",\"RMSE_lambda\",\"RMSE_mu\")]  df10_long <- melt(df10, id.vars=c(\"G\")) p14 <- ggplot(df10_long, aes(x=factor(G),y=value,fill=variable))+   geom_boxplot()  +  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(\"RMSE of lambda and mu\") + scale_fill_discrete(labels = c(\"Lambda\",\"Mu\"))+labs(y=\"RMSE\",x=\"G\")+ guides(fill=guide_legend(title=\"\")) p14 df11 = result[c(\"G\",\"G_CoOP\")]  df11_long <- melt(df11, id.vars=c(\"G\")) p11 <- ggplot(df11_long, aes(x=factor(G),y=value,fill=variable))+   geom_boxplot()  +  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(\"Estimation of G\") +   scale_fill_discrete(labels = c(\"Estimated G\"))+labs(x=\"G\")+ guides(fill=guide_legend(title=\"\")) p11"},{"path":"/articles/Example_on_other_settings.html","id":"n_ij-is-a-gamma-poisson-mixture","dir":"Articles","previous_headings":"","what":"\\(N_{i,j}\\) is a Gamma-Poisson mixture","title":"Example on other settings","text":"order increase variance \\(N_{,j}\\), now \\(N_{,j}\\sim\\mathcal{P}(\\nu_{,j})\\) \\(\\nu_{,j}\\) Gamma random variable shape \\(G/p\\) scale \\(\\lambda_i\\mu_jp\\) \\(p\\) positive number. example take \\(p = 4\\).","code":"result1 = data.frame(ARI_row_LBM=numeric(),                     ARI_col_LBM=numeric(),                     ARI_row_CoOP = numeric(),                     ARI_col_CoOP = numeric(),                     AUC_LBM = numeric(),                     AUC_CoOP = numeric()                    ) for (k in 1:30){ simulation1=simulate_lbm(P,alpha1,alpha2,n1,n2) M = simulation1$A Z1 =simulation1$Z Z2 =simulation1$W lambda_i =rbeta(n1,0.3,1.5) mu_j = rbeta(n2,0.3,1.5) lambda_i = lambda_i/max(lambda_i) mu_j = mu_j/max(mu_j) N0=rgamma(n=n1*n2,shape=G/4,scale=lambda_i%*%t(mu_j)*4) N=matrix(rpois(n1*n2,N0),nrow=n1) R = M*N  obsrow = rowSums(R)>0 obscol = colSums(R)>0 R_obs = R[obsrow,obscol] M_obs = M[obsrow,obscol] Z1_obs = Z1[obsrow] Z2_obs = Z2[obscol] V = 1*(R_obs>0) try1=fit_unsupervised_LBM(V,exploOptions = list(plot=FALSE,verbosity=F)) try2=fit_unsupervised_CoOP_LBM(R_obs,exploOptions = list(plot=F,verbosity=F))  model1 = try1[[best_ICL(try1)]] model2 = try2[[best_ICL(try2)]]  proba_connect1 = model1$pi[model1$cluster1,model1$cluster2] proba_connect2 = model2$connectivity_prob    ARIL1=ARI(model1$cluster1,Z1_obs) ARIC1=ARI(model1$cluster2,Z2_obs)  ARIL2=ARI(model2$cluster1,Z1_obs) ARIC2=ARI(model2$cluster2,Z2_obs)  AUC_LBM  = auc(roc(M_obs[V==0],proba_connect1[V==0],                    direction=\"<\",levels=levels(as.factor(c(0,1))))) AUC_CoOP = auc(roc(M_obs[V==0],proba_connect2[V==0],                    direction=\"<\",levels=levels(as.factor(c(0,1)))))  result1[nrow(result1)+1,] = c(ARIL1,ARIC1,ARIL2,ARIC2,AUC_LBM,AUC_CoOP)  } df1 = result1[c(\"ARI_row_LBM\",\"ARI_row_CoOP\")] df1 = melt(df1) #> No id variables; using all as measure variables p1 <- ggplot(df1, aes(y=value,fill=variable))+   geom_boxplot() +  theme(legend.position = \"bottom\",axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(\"ARI for row clustering\")+ labs(y=\"ARI\",x=\"\")+scale_fill_discrete(labels = c(\"LBM\",\"CoOP-LBM\"))+ guides(fill=guide_legend(title=\"\"))+theme(axis.title.x=element_blank(),         axis.text.x=element_blank(),         axis.ticks.x=element_blank())+ylim(c(0,1))  df2 = result1[c(\"ARI_col_LBM\",\"ARI_col_CoOP\")] df2 = melt(df2) #> No id variables; using all as measure variables p2 <- ggplot(df2, aes(y=value,fill=variable))+   geom_boxplot()  +  theme(legend.position = \"bottom\",axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(\"ARI for column clustering\")+ labs(y=\"\",x=\"\")+scale_fill_discrete(labels = c(\"LBM\",\"CoOP-LBM\")) + guides(fill=guide_legend(title=\"\"))+theme(axis.title.x=element_blank(),         axis.text.x=element_blank(),         axis.ticks.x=element_blank())+ylim(c(0,1))   grid.arrange(p1,p2,ncol=2) df3 = result1[c(\"AUC_LBM\",\"AUC_CoOP\")]  df3_long <- melt(df3) #> No id variables; using all as measure variables p3 <- ggplot(df3_long, aes(y=value,fill=variable))+   geom_boxplot()  +  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(\"AUC for missing data\")+scale_fill_discrete(labels = c(\"LBM\",\"CoOP-LBM\")) + guides(fill=guide_legend(title=\"\"))+labs(y=\"AUC\")+theme(axis.title.x=element_blank(),         axis.text.x=element_blank(),         axis.ticks.x=element_blank())+ylim(c(0,1)) p3"},{"path":"/articles/Example_on_other_settings.html","id":"lambda-and-mu-are-structured-in-cluster-independent-from-z1-and-z2","dir":"Articles","previous_headings":"","what":"\\(\\lambda\\) and \\(\\mu\\) are structured in cluster independent from \\(Z^1\\) and \\(Z^2\\)","title":"Example on other settings","text":"situation, \\(\\lambda\\) \\(\\mu\\) also structured, simulation done see structure sampling can perturb estimation networkâ€™s structure.","code":"result2 = data.frame(ARI_row_LBM=numeric(),                     ARI_col_LBM=numeric(),                     ARI_row_CoOP = numeric(),                     ARI_col_CoOP = numeric(),                     AUC_LBM = numeric(),                     AUC_CoOP = numeric()                    ) for (k in 1:30){ simulation1=simulate_lbm(P,alpha1,alpha2,n1,n2) M = simulation1$A Z1 =simulation1$Z Z2 =simulation1$W lambda_i =sample(c(0.01,0.25,0.5),size=100,replace=T,prob=c(0.5,0.4,0.1)) mu_j = sample(c(0.01,0.25,0.5),size=100,replace=T,prob=c(0.5,0.4,0.1)) lambda_i = lambda_i/max(lambda_i) mu_j = mu_j/max(mu_j) N0=lambda_i%*%t(mu_j)*G N=matrix(rpois(n1*n2,N0),nrow=n1) R = M*N  obsrow = rowSums(R)>0 obscol = colSums(R)>0 R_obs = R[obsrow,obscol] M_obs = M[obsrow,obscol] Z1_obs = Z1[obsrow] Z2_obs = Z2[obscol] V = 1*(R_obs>0) try1=fit_unsupervised_LBM(V,exploOptions = list(plot=FALSE,verbosity=F)) try2=fit_unsupervised_CoOP_LBM(R_obs,exploOptions = list(plot=F,verbosity=F))  model1 = try1[[best_ICL(try1)]] model2 = try2[[best_ICL(try2)]]  proba_connect1 = model1$pi[model1$cluster1,model1$cluster2] proba_connect2 = model2$connectivity_prob  AUC_LBM  = auc(roc(M_obs[V==0],proba_connect1[V==0],                    direction=\"<\",levels=levels(as.factor(c(0,1))))) AUC_CoOP = auc(roc(M_obs[V==0],proba_connect2[V==0],                    direction=\"<\",levels=levels(as.factor(c(0,1)))))  ARIL1=ARI(model1$cluster1,Z1_obs) ARIC1=ARI(model1$cluster2,Z2_obs)  ARIL2=ARI(model2$cluster1,Z1_obs) ARIC2=ARI(model2$cluster2,Z2_obs)  result2[nrow(result2)+1,] = c(ARIL1,ARIC1,ARIL2,ARIC2,AUC_LBM,AUC_CoOP)  } df1 = result2[c(\"ARI_row_LBM\",\"ARI_row_CoOP\")] df1 = melt(df1) #> No id variables; using all as measure variables p1 <- ggplot(df1, aes(y=value,fill=variable))+   geom_boxplot() +  theme(legend.position = \"bottom\",axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(\"ARI for row clustering\")+ labs(y=\"ARI\",x=\"\")+scale_fill_discrete(labels = c(\"LBM\",\"CoOP-LBM\"))+ guides(fill=guide_legend(title=\"\"))+theme(axis.title.x=element_blank(),         axis.text.x=element_blank(),         axis.ticks.x=element_blank())+ylim(c(0,1))  df2 = result2[c(\"ARI_col_LBM\",\"ARI_col_CoOP\")] df2 = melt(df2) #> No id variables; using all as measure variables p2 <- ggplot(df2, aes(y=value,fill=variable))+   geom_boxplot()  +  theme(legend.position = \"bottom\",axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(\"ARI for column clustering\")+ labs(y=\"\",x=\"\")+scale_fill_discrete(labels = c(\"LBM\",\"CoOP-LBM\")) + guides(fill=guide_legend(title=\"\"))+theme(axis.title.x=element_blank(),         axis.text.x=element_blank(),         axis.ticks.x=element_blank())+ylim(c(0,1))   grid.arrange(p1,p2,ncol=2) df3 = result2[c(\"AUC_LBM\",\"AUC_CoOP\")]  df3_long <- melt(df3) #> No id variables; using all as measure variables p3 <- ggplot(df3_long, aes(y=value,fill=variable))+   geom_boxplot()  +  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(\"AUC for missing data\")+scale_fill_discrete(labels = c(\"LBM\",\"CoOP-LBM\")) + guides(fill=guide_legend(title=\"\"))+labs(y=\"AUC\")+theme(axis.title.x=element_blank(),         axis.text.x=element_blank(),         axis.ticks.x=element_blank())+ylim(c(0,1)) p3"},{"path":"/articles/Example_on_other_settings.html","id":"one-line-is-over-sampled-compared-to-the-other","dir":"Articles","previous_headings":"","what":"One line is over sampled compared to the other","title":"Example on other settings","text":"situation, model usual, parameter \\(G\\) changed one line, represent sampled species.","code":"result3 = data.frame(ARI_row_LBM=numeric(),                     ARI_col_LBM=numeric(),                     ARI_row_CoOP = numeric(),                     ARI_col_CoOP = numeric(),                     AUC_LBM = numeric(),                     AUC_CoOP = numeric()                    ) for (k in 1:30){ simulation1=simulate_lbm(P,alpha1,alpha2,n1,n2) M = simulation1$A Z1 =simulation1$Z Z2 =simulation1$W lambda_i =rbeta(n1,0.3,1.5) mu_j = rbeta(n2,0.3,1.5) lambda_i = lambda_i/max(lambda_i) mu_j = mu_j/max(mu_j) N0=lambda_i%*%t(mu_j)*G N0[1,] = lambda_i[1] * mu_j * G * 6  N=matrix(rpois(n1*n2,N0),nrow=n1) R = M*N  obsrow = rowSums(R)>0 obscol = colSums(R)>0 R_obs = R[obsrow,obscol] M_obs = M[obsrow,obscol] Z1_obs = Z1[obsrow] Z2_obs = Z2[obscol] V = 1*(R_obs>0) try1=fit_unsupervised_LBM(V,exploOptions = list(plot=FALSE,verbosity=F)) try2=fit_unsupervised_CoOP_LBM(R_obs,exploOptions = list(plot=F,verbosity=F))  model1 = try1[[best_ICL(try1)]] model2 = try2[[best_ICL(try2)]]  proba_connect1 = model1$pi[model1$cluster1,model1$cluster2] proba_connect2 = model2$connectivity_prob  AUC_LBM  = auc(roc(M_obs[V==0],proba_connect1[V==0],                    direction=\"<\",levels=levels(as.factor(c(0,1))))) AUC_CoOP = auc(roc(M_obs[V==0],proba_connect2[V==0],                    direction=\"<\",levels=levels(as.factor(c(0,1)))))  ARIL1=ARI(model1$cluster1,Z1_obs) ARIC1=ARI(model1$cluster2,Z2_obs)  ARIL2=ARI(model2$cluster1,Z1_obs) ARIC2=ARI(model2$cluster2,Z2_obs) result3[nrow(result3)+1,] = c(ARIL1,ARIC1,ARIL2,ARIC2,AUC_LBM,AUC_CoOP)  } df1 = result3[c(\"ARI_row_LBM\",\"ARI_row_CoOP\")] df1 = melt(df1) #> No id variables; using all as measure variables p1 <- ggplot(df1, aes(y=value,fill=variable))+   geom_boxplot() +  theme(legend.position = \"bottom\",axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(\"ARI for row clustering\")+ labs(y=\"ARI\",x=\"\")+scale_fill_discrete(labels = c(\"LBM\",\"CoOP-LBM\"))+ guides(fill=guide_legend(title=\"\"))+theme(axis.title.x=element_blank(),         axis.text.x=element_blank(),         axis.ticks.x=element_blank())+ylim(c(0,1))  df2 = result3[c(\"ARI_col_LBM\",\"ARI_col_CoOP\")] df2 = melt(df2) #> No id variables; using all as measure variables p2 <- ggplot(df2, aes(y=value,fill=variable))+   geom_boxplot()  +  theme(legend.position = \"bottom\",axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(\"ARI for column clustering\")+ labs(y=\"\",x=\"\")+scale_fill_discrete(labels = c(\"LBM\",\"CoOP-LBM\")) + guides(fill=guide_legend(title=\"\"))+theme(axis.title.x=element_blank(),         axis.text.x=element_blank(),         axis.ticks.x=element_blank())+ylim(c(0,1))   grid.arrange(p1,p2,ncol=2) df3 = result3[c(\"AUC_LBM\",\"AUC_CoOP\")]  df3_long <- melt(df3) #> No id variables; using all as measure variables p3 <- ggplot(df3_long, aes(y=value,fill=variable))+   geom_boxplot()  +  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(\"AUC for missing data\")+scale_fill_discrete(labels = c(\"LBM\",\"CoOP-LBM\")) + guides(fill=guide_legend(title=\"\"))+labs(y=\"AUC\")+theme(axis.title.x=element_blank(),         axis.text.x=element_blank(),         axis.ticks.x=element_blank())+ylim(c(0,1)) p3"},{"path":"/articles/Example_on_other_settings.html","id":"global-sampling-effort-is-structured-in-cluster-independent-from-z1-and-z2","dir":"Articles","previous_headings":"","what":"Global sampling effort is structured in cluster independent from \\(Z^1\\) and \\(Z^2\\)","title":"Example on other settings","text":"situation, model usual, parameter \\(G\\) depends clustering independent \\(Z^1\\) \\(Z^2\\)","code":"result4 = data.frame(ARI_row_LBM=numeric(),                     ARI_col_LBM=numeric(),                     ARI_row_CoOP = numeric(),                     ARI_col_CoOP = numeric(),                     AUC_LBM = numeric(),                     AUC_CoOP = numeric()                    ) for (k in 1:30){  simulation1=simulate_lbm(P,alpha1,alpha2,n1,n2) M = simulation1$A Z1 =simulation1$Z Z2 =simulation1$W  G0 = matrix(runif(16),nrow=4)*50+10 Z1G = sample(1:4,size=n1,replace=T) Z2G = sample(1:4,size=n2,replace=T) G0 = G0[Z1G,Z2G] lambda_i =rbeta(n1,0.3,1.5) mu_j = rbeta(n2,0.3,1.5) lambda_i = lambda_i/max(lambda_i) mu_j = mu_j/max(mu_j) N0=lambda_i%*%t(mu_j)*G0 N=matrix(rpois(n1*n2,N0),nrow=n1) R = M*N  obsrow = rowSums(R)>0 obscol = colSums(R)>0 R_obs = R[obsrow,obscol] M_obs = M[obsrow,obscol] Z1_obs = Z1[obsrow] Z2_obs = Z2[obscol] V = 1*(R_obs>0) try1=fit_unsupervised_LBM(V,exploOptions = list(plot=FALSE,verbosity=F)) try2=fit_unsupervised_CoOP_LBM(R_obs,exploOptions = list(plot=F,verbosity=F))  model1 = try1[[best_ICL(try1)]] model2 = try2[[best_ICL(try2)]]  proba_connect1 = model1$pi[model1$cluster1,model1$cluster2] proba_connect2 = model2$connectivity_prob  AUC_LBM  = auc(roc(M_obs[V==0],proba_connect1[V==0],                    direction=\"<\",levels=levels(as.factor(c(0,1))))) AUC_CoOP = auc(roc(M_obs[V==0],proba_connect2[V==0],                    direction=\"<\",levels=levels(as.factor(c(0,1)))))  ARIL1=ARI(model1$cluster1,Z1_obs) ARIC1=ARI(model1$cluster2,Z2_obs)  ARIL2=ARI(model2$cluster1,Z1_obs) ARIC2=ARI(model2$cluster2,Z2_obs) result4[nrow(result4)+1,] = c(ARIL1,ARIC1,ARIL2,ARIC2,AUC_LBM,AUC_CoOP)  } df1 = result4[c(\"ARI_row_LBM\",\"ARI_row_CoOP\")] df1 = melt(df1) #> No id variables; using all as measure variables p1 <- ggplot(df1, aes(y=value,fill=variable))+   geom_boxplot() +  theme(legend.position = \"bottom\",axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(\"ARI for row clustering\")+ labs(y=\"ARI\",x=\"\")+scale_fill_discrete(labels = c(\"LBM\",\"CoOP-LBM\"))+ guides(fill=guide_legend(title=\"\"))+theme(axis.title.x=element_blank(),         axis.text.x=element_blank(),         axis.ticks.x=element_blank())+ylim(c(0,1))  df2 = result4[c(\"ARI_col_LBM\",\"ARI_col_CoOP\")] df2 = melt(df2) #> No id variables; using all as measure variables p2 <- ggplot(df2, aes(y=value,fill=variable))+   geom_boxplot()  +  theme(legend.position = \"bottom\",axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(\"ARI for column clustering\")+ labs(y=\"\",x=\"\")+scale_fill_discrete(labels = c(\"LBM\",\"CoOP-LBM\")) + guides(fill=guide_legend(title=\"\"))+theme(axis.title.x=element_blank(),         axis.text.x=element_blank(),         axis.ticks.x=element_blank())+ylim(c(0,1))   grid.arrange(p1,p2,ncol=2) df3 = result4[c(\"AUC_LBM\",\"AUC_CoOP\")]  df3_long <- melt(df3) #> No id variables; using all as measure variables p3 <- ggplot(df3_long, aes(y=value,fill=variable))+   geom_boxplot()  +  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(\"AUC for missing data\")+scale_fill_discrete(labels = c(\"LBM\",\"CoOP-LBM\")) + guides(fill=guide_legend(title=\"\"))+labs(y=\"AUC\")+theme(axis.title.x=element_blank(),         axis.text.x=element_blank(),         axis.ticks.x=element_blank())+ylim(c(0,1)) p3"},{"path":"/articles/Example_on_other_settings.html","id":"lambda-and-mu-are-structured-in-cluster-indentical-to-z1-and-z2","dir":"Articles","previous_headings":"","what":"\\(\\lambda\\) and \\(\\mu\\) are structured in cluster indentical to \\(Z^1\\) and \\(Z^2\\)","title":"Example on other settings","text":"situation, \\(\\lambda\\) \\(\\mu\\) also structured, simulation done see structure sampling can perturb estimation networkâ€™s structure.","code":"result5 = data.frame(ARI_row_LBM=numeric(),                     ARI_col_LBM=numeric(),                     ARI_row_CoOP = numeric(),                     ARI_col_CoOP = numeric(),                     AUC_LBM = numeric(),                     AUC_CoOP = numeric()                    ) G=20 for (k in 1:30){ simulation1=simulate_lbm(P,alpha1,alpha2,n1,n2) M = simulation1$A Z1 =simulation1$Z Z2 =simulation1$W v1 = c(1,rbeta(2,0.3,1.5)) v2 = c(1,rbeta(2,0.3,1.5)) v1=sample(v1) v2=sample(v2) lambda_i =v1[Z1] mu_j =v2[Z2] N0=lambda_i%*%t(mu_j)*G N=matrix(rpois(n1*n2,N0),nrow=n1) R = M*N  obsrow = rowSums(R)>0 obscol = colSums(R)>0 R_obs = R[obsrow,obscol] M_obs = M[obsrow,obscol] Z1_obs = Z1[obsrow] Z2_obs = Z2[obscol] V = 1*(R_obs>0) try1=fit_unsupervised_LBM(V,exploOptions = list(plot=FALSE,verbosity=F)) try2=fit_unsupervised_CoOP_LBM(R_obs,exploOptions = list(plot=F,verbosity=F))  model1 = try1[[best_ICL(try1)]] model2 = try2[[best_ICL(try2)]]  proba_connect1 = model1$pi[model1$cluster1,model1$cluster2] proba_connect2 = model2$connectivity_prob  AUC_LBM  = auc(roc(M_obs[V==0],proba_connect1[V==0],                    direction=\"<\",levels=levels(as.factor(c(0,1))))) AUC_CoOP = auc(roc(M_obs[V==0],proba_connect2[V==0],                    direction=\"<\",levels=levels(as.factor(c(0,1)))))  ARIL1=ARI(model1$cluster1,Z1_obs) ARIC1=ARI(model1$cluster2,Z2_obs)  ARIL2=ARI(model2$cluster1,Z1_obs) ARIC2=ARI(model2$cluster2,Z2_obs)  result5[nrow(result5)+1,] = c(ARIL1,ARIC1,ARIL2,ARIC2,AUC_LBM,AUC_CoOP)  } df1 = result5[c(\"ARI_row_LBM\",\"ARI_row_CoOP\")] df1 = melt(df1) #> No id variables; using all as measure variables p1 <- ggplot(df1, aes(y=value,fill=variable))+   geom_boxplot() +  theme(legend.position = \"bottom\",axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(\"ARI for row clustering\")+ labs(y=\"ARI\",x=\"\")+scale_fill_discrete(labels = c(\"LBM\",\"CoOP-LBM\"))+ guides(fill=guide_legend(title=\"\"))+theme(axis.title.x=element_blank(),         axis.text.x=element_blank(),         axis.ticks.x=element_blank())+ylim(c(0,1))  df2 = result5[c(\"ARI_col_LBM\",\"ARI_col_CoOP\")] df2 = melt(df2) #> No id variables; using all as measure variables p2 <- ggplot(df2, aes(y=value,fill=variable))+   geom_boxplot()  +  theme(legend.position = \"bottom\",axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(\"ARI for column clustering\")+ labs(y=\"\",x=\"\")+scale_fill_discrete(labels = c(\"LBM\",\"CoOP-LBM\")) + guides(fill=guide_legend(title=\"\"))+theme(axis.title.x=element_blank(),         axis.text.x=element_blank(),         axis.ticks.x=element_blank())+ylim(c(0,1))   grid.arrange(p1,p2,ncol=2) df3 = result5[c(\"AUC_LBM\",\"AUC_CoOP\")]  df3_long <- melt(df3) #> No id variables; using all as measure variables p3 <- ggplot(df3_long, aes(y=value,fill=variable))+   geom_boxplot()  +  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(\"AUC for missing data\")+scale_fill_discrete(labels = c(\"LBM\",\"CoOP-LBM\")) + guides(fill=guide_legend(title=\"\"))+labs(y=\"AUC\")+theme(axis.title.x=element_blank(),         axis.text.x=element_blank(),         axis.ticks.x=element_blank())+ylim(c(0,1)) p3"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Emre ANAKOK. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"ANAKOK E (2022). CoOPLBM: Corrected Observation Process Latent Block Model. R package version 0.0.0.9000.","code":"@Manual{,   title = {CoOPLBM: Corrected Observation Process for Latent Block Model},   author = {Emre ANAKOK},   year = {2022},   note = {R package version 0.0.0.9000}, }"},{"path":"/index.html","id":"cooplbm","dir":"","previous_headings":"","what":"Corrected Observation Process for Latent Block Model","title":"Corrected Observation Process for Latent Block Model","text":"goal CoOPLBM correct Latent Block Model (LBM) data missing taking account counting data. package allows fit CoOP-LBM bipartite graph, represented contigency table number interaction observed.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Corrected Observation Process for Latent Block Model","text":"can install development version CoOPLBM GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"AnakokEmre/CoOP-LBM\")"},{"path":"/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Corrected Observation Process for Latent Block Model","text":"","code":"library(CoOPLBM)"},{"path":"/reference/best_ICL.html","id":null,"dir":"Reference","previous_headings":"","what":"Best ICL â€” best_ICL","title":"Best ICL â€” best_ICL","text":"Best ICL","code":""},{"path":"/reference/best_ICL.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Best ICL â€” best_ICL","text":"","code":"best_ICL(models)"},{"path":"/reference/best_ICL.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Best ICL â€” best_ICL","text":"models list model ICL","code":""},{"path":"/reference/best_ICL.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Best ICL â€” best_ICL","text":"index model best ICL","code":""},{"path":"/reference/best_ICL.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Best ICL â€” best_ICL","text":"","code":"n1 = 100 n2 = 100 Q1=3 Q2=3 alpha1=c(.25,0.25, .5) alpha2=c(0.10,0.4,0.5) P <- matrix(c(0.9,0.6,0.4,0.7,0.5,0.3,0.5,0.3,0.1), Q1, Q2) simulation1=robber::simulate_lbm(P,alpha1,alpha2,n1,n2) M = simulation1$A Z1 =simulation1$Z Z2 =simulation1$W G= 300 lambda_i =rbeta(n1,0.3,1.5) mu_j = rbeta(n2,0.3,1.5) lambda_i = lambda_i/max(lambda_i) mu_j = mu_j/max(mu_j) N0=lambda_i%*%t(mu_j) N0 = N0*G N=matrix(rpois(n1*n2,N0),nrow=n1) R = M*N obsrow = rowSums(R)>0 obscol = colSums(R)>0 R_obs = R[obsrow,obscol] M_obs = M[obsrow,obscol] R = M*N models=fit_unsupervised_CoOP_LBM(R,exploOptions=list(plot=F)) #> [1] \"k={ 1 , 1 }\" #> [1] \"k={ 2 , 1 }\" #> [1] \"k={ 1 , 2 }\" #> [1] \"k={ 2 , 2 }\" #> [1] \"k={ 3 , 1 }\" #> [1] \"k={ 3 , 2 }\" #> [1] \"k={ 1 , 3 }\" #> [1] \"k={ 2 , 3 }\" #> [1] \"k={ 3 , 3 }\" #> [1] \"k={ 4 , 1 }\" #> [1] \"k={ 4 , 2 }\" #> [1] \"k={ 4 , 3 }\" #> [1] \"k={ 1 , 4 }\" #> [1] \"k={ 2 , 4 }\" #> [1] \"k={ 3 , 4 }\" #> [1] \"k={ 4 , 4 }\" #> [1] \"CoOP-LBM : Best model has been fitted with 2-2 groups.\" print(best_ICL(models)) #> 2-2  #>   4"},{"path":"/reference/clustinit_LBM.html","id":null,"dir":"Reference","previous_headings":"","what":"Clustering initialization â€” clustinit_LBM","title":"Clustering initialization â€” clustinit_LBM","text":"Clustering initialization","code":""},{"path":"/reference/clustinit_LBM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clustering initialization â€” clustinit_LBM","text":"","code":"clustinit_LBM(connectivity, Q1, Q2, type = \"hierarchical_clust\")"},{"path":"/reference/clustinit_LBM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clustering initialization â€” clustinit_LBM","text":"connectivity Binary matrix Q1 number clusters rows Q2 number clusters columns type type initialization : \"hierarchical_clust\", \"spectral_clust\" \"kmeans_clust\"","code":""},{"path":"/reference/clustinit_LBM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clustering initialization â€” clustinit_LBM","text":"List containing initial clustering rows columns","code":""},{"path":"/reference/clustinit_LBM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clustering initialization â€” clustinit_LBM","text":"","code":"a<- matrix(0,10,10) a[1:5,1:5] = runif(25)<0.9 a[6:10,1:5] = runif(25)<0.5 a[1:5,6:10] = runif(25)<0.3 a[6:10,6:10] = runif(25)<0.1 print(a) #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #>  [1,]    1    1    1    1    1    1    0    0    0     1 #>  [2,]    0    1    0    1    1    0    1    0    0     0 #>  [3,]    1    1    1    1    1    0    0    1    0     0 #>  [4,]    1    1    1    1    1    0    1    1    0     0 #>  [5,]    1    1    1    1    1    0    1    1    0     0 #>  [6,]    1    0    1    0    1    0    0    0    0     0 #>  [7,]    1    1    0    1    0    0    0    1    0     0 #>  [8,]    0    0    0    1    0    0    1    0    0     0 #>  [9,]    1    1    0    0    1    0    0    0    0     0 #> [10,]    0    1    1    0    0    0    1    0    0     1 print(clustinit_LBM(a,2,2)) #> [[1]] #>  [1] 1 2 1 1 1 1 1 2 1 2 #>  #> [[2]] #>  [1] 1 1 1 1 1 2 1 1 2 2 #>"},{"path":"/reference/CoOPLBM-package.html","id":null,"dir":"Reference","previous_headings":"","what":"CoOPLBM: Corrected Observation Process for Latent Block Model â€” CoOPLBM-package","title":"CoOPLBM: Corrected Observation Process for Latent Block Model â€” CoOPLBM-package","text":"taking account counting data, possible correct latent block model (LBM) data missing. package allows fit CoOP-LBM bipartite graph, represented contigency table number interaction observed.","code":""},{"path":"/reference/CoOPLBM-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"CoOPLBM: Corrected Observation Process for Latent Block Model â€” CoOPLBM-package","text":"Maintainer: Emre ANAKOK emre.anakok@agroparistech.fr (ORCID)","code":""},{"path":"/reference/fit_supervised_CoOP_LBM.html","id":null,"dir":"Reference","previous_headings":"","what":"Corrected Observation Process for Latent Block Model â€” fit_supervised_CoOP_LBM","title":"Corrected Observation Process for Latent Block Model â€” fit_supervised_CoOP_LBM","text":"Corrected Observation Process Latent Block Model","code":""},{"path":"/reference/fit_supervised_CoOP_LBM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Corrected Observation Process for Latent Block Model â€” fit_supervised_CoOP_LBM","text":"","code":"fit_supervised_CoOP_LBM(R, Q1, Q2, Z1 = c(), Z2 = c(), estimOptions = list())"},{"path":"/reference/fit_supervised_CoOP_LBM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Corrected Observation Process for Latent Block Model â€” fit_supervised_CoOP_LBM","text":"R Counting data connectivity matrix Q1 Number row clusters Q2 Number columns clusters Z1 Initial clustering rows Z2 Initial clustering columns estimOptions List parameters","code":""},{"path":"/reference/fit_supervised_CoOP_LBM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Corrected Observation Process for Latent Block Model â€” fit_supervised_CoOP_LBM","text":"Estimated LBM parameters, clustering, lambda, mu G given number groups.","code":""},{"path":"/reference/fit_supervised_LBM.html","id":null,"dir":"Reference","previous_headings":"","what":"Variational Expectation Maximization for LBM â€” fit_supervised_LBM","title":"Variational Expectation Maximization for LBM â€” fit_supervised_LBM","text":"Variational Expectation Maximization LBM","code":""},{"path":"/reference/fit_supervised_LBM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Variational Expectation Maximization for LBM â€” fit_supervised_LBM","text":"","code":"fit_supervised_LBM(   connectivity,   Q1,   Q2,   Z1 = c(),   Z2 = c(),   estimOptions = list() )"},{"path":"/reference/fit_supervised_LBM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Variational Expectation Maximization for LBM â€” fit_supervised_LBM","text":"connectivity Binary matrix connectivity Q1 Number row clusters Q2 Number column clusters Z1 Initial clustering rows Z2 Initial clustering columns param List parameters","code":""},{"path":"/reference/fit_supervised_LBM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Variational Expectation Maximization for LBM â€” fit_supervised_LBM","text":"Estimated LBM parameters clustering","code":""},{"path":"/reference/fit_unsupervised_CoOP_LBM.html","id":null,"dir":"Reference","previous_headings":"","what":"Main algorithm for CoOP-LBM estimation using counting data â€” fit_unsupervised_CoOP_LBM","title":"Main algorithm for CoOP-LBM estimation using counting data â€” fit_unsupervised_CoOP_LBM","text":"Main algorithm CoOP-LBM estimation using counting data","code":""},{"path":"/reference/fit_unsupervised_CoOP_LBM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Main algorithm for CoOP-LBM estimation using counting data â€” fit_unsupervised_CoOP_LBM","text":"","code":"fit_unsupervised_CoOP_LBM(   connectivity,   estimOptions = list(),   exploOptions = list() )"},{"path":"/reference/fit_unsupervised_CoOP_LBM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Main algorithm for CoOP-LBM estimation using counting data â€” fit_unsupervised_CoOP_LBM","text":"connectivity Counting data connectivity estimOptions list options estimation exploOptions list options exploration","code":""},{"path":"/reference/fit_unsupervised_CoOP_LBM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Main algorithm for CoOP-LBM estimation using counting data â€” fit_unsupervised_CoOP_LBM","text":"List model different number cluster","code":""},{"path":"/reference/fit_unsupervised_CoOP_LBM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Main algorithm for CoOP-LBM estimation using counting data â€” fit_unsupervised_CoOP_LBM","text":"","code":"n1 = 100 n2 = 100 Q1=3 Q2=3 alpha1=c(.25,0.25, .5) alpha2=c(0.10,0.4,0.5) P <- matrix(c(0.9,0.6,0.4,0.7,0.5,0.3,0.5,0.3,0.1), Q1, Q2) simulation1=robber::simulate_lbm(P,alpha1,alpha2,n1,n2) M = simulation1$A Z1 =simulation1$Z Z2 =simulation1$W G= 300 lambda_i =rbeta(n1,0.3,1.5) mu_j = rbeta(n2,0.3,1.5) lambda_i = lambda_i/max(lambda_i) mu_j = mu_j/max(mu_j) N0=lambda_i%*%t(mu_j) N0 = N0*G N=matrix(rpois(n1*n2,N0),nrow=n1) R = M*N obsrow = rowSums(R)>0 obscol = colSums(R)>0 R_obs = R[obsrow,obscol] M_obs = M[obsrow,obscol] R = M*N models=fit_unsupervised_CoOP_LBM(R,exploOptions=list(plot=F)) #> [1] \"k={ 1 , 1 }\" #> [1] \"k={ 2 , 1 }\" #> [1] \"k={ 1 , 2 }\" #> [1] \"k={ 2 , 2 }\" #> [1] \"k={ 3 , 1 }\" #> [1] \"k={ 3 , 2 }\" #> [1] \"k={ 1 , 3 }\" #> [1] \"k={ 2 , 3 }\" #> [1] \"k={ 3 , 3 }\" #> [1] \"k={ 4 , 1 }\" #> [1] \"k={ 4 , 2 }\" #> [1] \"k={ 4 , 3 }\" #> [1] \"k={ 1 , 4 }\" #> [1] \"k={ 2 , 4 }\" #> [1] \"k={ 3 , 4 }\" #> [1] \"k={ 4 , 4 }\" #> [1] \"k={ 5 , 1 }\" #> [1] \"k={ 5 , 2 }\" #> [1] \"k={ 5 , 3 }\" #> [1] \"k={ 5 , 4 }\" #> [1] \"CoOP-LBM : Best model has been fitted with 3-2 groups.\""},{"path":"/reference/fit_unsupervised_LBM.html","id":null,"dir":"Reference","previous_headings":"","what":"Main algorithm for LBM estimation using binary data â€” fit_unsupervised_LBM","title":"Main algorithm for LBM estimation using binary data â€” fit_unsupervised_LBM","text":"Main algorithm LBM estimation using binary data","code":""},{"path":"/reference/fit_unsupervised_LBM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Main algorithm for LBM estimation using binary data â€” fit_unsupervised_LBM","text":"","code":"fit_unsupervised_LBM(   connectivity,   estimOptions = list(),   exploOptions = list() )"},{"path":"/reference/fit_unsupervised_LBM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Main algorithm for LBM estimation using binary data â€” fit_unsupervised_LBM","text":"connectivity binary connectivity estimOptions list options estimation exploOptions list options exploration","code":""},{"path":"/reference/fit_unsupervised_LBM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Main algorithm for LBM estimation using binary data â€” fit_unsupervised_LBM","text":"List model different number cluster","code":""},{"path":"/reference/fit_unsupervised_LBM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Main algorithm for LBM estimation using binary data â€” fit_unsupervised_LBM","text":"","code":"n1 = 100 n2 = 100 Q1=3 Q2=3 alpha1=c(.25,0.25, .5) alpha2=c(0.10,0.4,0.5) P <- matrix(c(0.9,0.6,0.4,0.7,0.5,0.3,0.5,0.3,0.1), Q1, Q2) simulation1=robber::simulate_lbm(P,alpha1,alpha2,n1,n2) M = simulation1$A Z1 =simulation1$Z Z2 =simulation1$W G= 300 lambda_i =rbeta(n1,0.3,1.5) mu_j = rbeta(n2,0.3,1.5) lambda_i = lambda_i/max(lambda_i) mu_j = mu_j/max(mu_j) N0=lambda_i%*%t(mu_j) N0 = N0*G N=matrix(rpois(n1*n2,N0),nrow=n1) R = M*N obsrow = rowSums(R)>0 obscol = colSums(R)>0 R_obs = R[obsrow,obscol] M_obs = M[obsrow,obscol] R = M*N models=fit_unsupervised_LBM(R,exploOptions=list(plot=F)) #> [1] \"k={ 1 , 1 }\" #> [1] \"k={ 2 , 1 }\" #> [1] \"k={ 1 , 2 }\" #> [1] \"k={ 2 , 2 }\" #> [1] \"k={ 3 , 1 }\" #> [1] \"k={ 3 , 2 }\" #> [1] \"k={ 1 , 3 }\" #> [1] \"k={ 2 , 3 }\" #> [1] \"k={ 3 , 3 }\" #> [1] \"k={ 4 , 1 }\" #> [1] \"k={ 4 , 2 }\" #> [1] \"k={ 4 , 3 }\" #> [1] \"k={ 1 , 4 }\" #> [1] \"k={ 2 , 4 }\" #> [1] \"k={ 3 , 4 }\" #> [1] \"k={ 4 , 4 }\" #> [1] \"k={ 5 , 1 }\" #> [1] \"k={ 5 , 2 }\" #> [1] \"k={ 5 , 3 }\" #> [1] \"k={ 5 , 4 }\" #> [1] \"k={ 1 , 5 }\" #> [1] \"k={ 2 , 5 }\" #> [1] \"k={ 3 , 5 }\" #> [1] \"k={ 4 , 5 }\" #> [1] \"k={ 5 , 5 }\" #> [1] \"k={ 6 , 1 }\" #> [1] \"k={ 6 , 2 }\" #> [1] \"k={ 6 , 3 }\" #> [1] \"k={ 6 , 4 }\" #> [1] \"k={ 6 , 5 }\" #> [1] \"LBM : Best model has been fitted with 4-3 groups.\""},{"path":"/reference/NODF.html","id":null,"dir":"Reference","previous_headings":"","what":"Nestedness metric based on Overlap and Decreasing Fill â€” NODF","title":"Nestedness metric based on Overlap and Decreasing Fill â€” NODF","text":"Nestedness metric based Overlap Decreasing Fill","code":""},{"path":"/reference/NODF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nestedness metric based on Overlap and Decreasing Fill â€” NODF","text":"","code":"NODF(Matrix)"},{"path":"/reference/NODF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nestedness metric based on Overlap and Decreasing Fill â€” NODF","text":"Matrix","code":""},{"path":"/reference/NODF.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nestedness metric based on Overlap and Decreasing Fill â€” NODF","text":"List NODF matrix,averaged row, column, full matrix","code":""}]
